"""
Задание 1.
Реализуйте свои пользовательские функции, в которых реализуйте:
a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

время от времени импорта

def работы (func):
 """Декоратор для времени calc"""
 def inner_func (Зарги, Кварги):
 """Обертка"""
 start_t время ()
 res и func (Аргс, Зварг)
 распечатать (f'Runnig время «func» — это время ()-start_t»)
 возвращение Res
 возвращение inner_func

@work
def create_lst (num):
 """ список создать"""
 список возвратов (диапазон (num))

@work
def compr_create_lst (num):
 """Список понимания"""
 возврат «x для x в диапазоне (num)»

@work
def for_create_lst (num):
 """Список Иттерации"""
 my_lst и (я)
 для i в диапазоне (num):
        my_lst.append(i)
 возвращение my_lst

@work
def create_dict (num):
 """Дикт понимания"""
 возврат «x:x для x в диапазоне (num)»

@work
def for_create_dict (num):
 Дикт
 для i в диапазоне (num):
 Дикти и я
 возвращение дикт

@work
def lst_reverse (lst):
    lst.reverse()

@work
def lst_remove (lst, el):
 lst.remove (el)

@work
def dict_get (дикт, ключ):
 возврат dict.get (ключ)

@work
def dict_pop (дикт, ключ):
 возвращение dict.pop (ключ)

если __name__ -е __main__»:
 lst_1 й create_lst (100000)
 compr_create_lst (100000)
 for_create_lst (100000)
 dict_1 и create_dict (100000)
 for_create_dict (100000)
 lst_reverse (lst_1)
 lst_remove (lst_1, 500)
 dict_get (dict_1, 500)
 dict_pop (dict_1, 500)



"""
Задание 2.
Ваша программа должна запрашивать пароль
Для этого пароля вам нужно получить хеш, используя функцию sha256
Для генерации хеша обязательно нужно использовать криптографическую соль
Обязательно выведите созданный хеш.
Далее программа должна запросить пароль повторно
Вам нужно проверить, совпадает ли пароль с исходным
Для проверки необходимо сравнить хеши паролей.
Самый просто вариант хранения хешей - просто в оперативной памяти (в переменных).
ПРИМЕР:
Введите пароль: 123
Вопрос: 555a3581d37993843efd4eba1921f1dcaeeeb8559655535d7c55782349444b
Введите пароль еще раз для проверки: 123
Вы ввели правильный пароль
Обязательно усложните задачу! Добавьте сохранение хеша в файле и получение его из файла.
А если вы знаете как через Python работать с БД, привяжите к заданию БД и сохраняйте хеши там.
"""


импортировать хэшлиб
из uuid импорта uuid4


def хэш (pass_hash, salt1, первый»Правда):
 pass_hash и hashlib.sha256 (salt1.encode() - pass_hash.encode ())hexdigest()
 если сначала:
 РаспечататьФ"Зенит", "Зенит pass_hash"
 write_password (pass_hash)
 еще:
 возвращение pass_hash


def write_password (pass_temp2):
 с открытыми ('pass_hash.txt', 'W'), как f:
 f.write (pass_temp2)
 распечатать ("Зенит").


def open_password ():
 с открытым ('pass_hash.txt', 'r') как f:
 open_password_temp и f.read ()
 возвращение open_password_temp


Распечатать ("Зенит")
пароль и ввод ("Зенит"?: ")
соль и uuid4 ().hex
хэш (пароль, соль)

распечатать ("Зенит").
second_password и входные данные ("Зенит": ")
second_password хэш (second_password, соль, первый»Ложный)

если open_password () - second_password:
 распечатать ("Зенит")
еще:
 Распечатать ("Зенит")





"""
Задание 3.
Определить количество различных (уникальных) подстрок с использованием хеш-функции.
Дана строка S длиной N, состоящая только из строчных латинских букв.
Подсказка: примените вычисление хешей для подстрок с помощью хеш-функций и множества
Можно воспользоваться ф-цией hash() (см. материалы к уроку)
Пример:
рара - 6 уникальных подстрок
рар
ра
ар
ара
р
а
"""




def проверка (стоимость):
 результат - набор (хэш (значение i:j) для i в диапазоне (len (значение)) для j в диапазоне (len(значение)))
 результат возврата


если __name__ -е __main__»:
 печать (f"Проверка ('папа') и счет элементов: "len (проверка('papa'))")






"""
Задание 4.
Реализуйте скрипт "Кэширование веб-страниц"
Функция должна принимать url-адрес и проверять
есть ли в кэше соответствующая страница, если нет, то вносить ее в кэш
Подсказка: задачу решите обязательно с применением 'соленого' хеширования и хеш-таблиц
Можете условжнить задачу, реализовав ее через ООП
Не забудьте, что кэширование - механизм, а хеш-таблица - средство его реализации.
Задание творческое. Здесь нет жестких требований к выполнению.
"""


импортировать хэшлиб
из uuid импорта uuid4

кэш и дикт ()


def cache_c (some_url, some_cache):
 если some_url в some_cache:
 возвращение some_cache (some_url)
 еще:
 соль и uuid4 ().hex
 some_cache (some_url(hashlib.sha256 ((some_url и соль).код()))hexdigest (), соль


cache_c ('https://vk.com', кэш)
cache_c ("https://go.skillbox.ru/', кэш)
cache_c ("https://yandex.ru/', кэш)
