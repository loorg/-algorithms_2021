"""
Задание 1.
Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива
Сделайте замеры времени выполнения кода с помощью модуля timeit
Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.
Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается
И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""
from timeit import timeit

def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr



def func_2(nums):
    return [s for s, num in enumerate(nums) if num % 2 == 0]


print(timeit('func_1([v for v in range(100)])', globals=globals(), number=1000))
print(timeit('func_2([t for t in range(100)])', globals=globals(), number=100000))
# время выполнение первой 0.0528092
# время выполнения второй  3.6976286999999997




"""
Задание 2.
Приведен код, который формирует из введенного числа
обратное по порядку входящих в него цифр.
Задача решена через рекурсию
Выполнена попытка оптимизировать решение через мемоизацию.
Сделаны замеры обеих реализаций.
Сделайте аналитику, нужна ли здесь мемоизация или нет и почему?!!!
Будьте внимательны, задание хитрое. Не все так просто, как кажется.
"""

from timeit import timeit
from random import randint


def recursive_reverse(number):
    if number == 0:
        return ''
    return f'{str(number % 10)}{recursive_reverse(number // 10)}'


num_100 = randint(10000, 1000000)
num_1000 = randint(1000000, 10000000)
num_10000 = randint(100000000, 10000000000000)

print('Не оптимизированная функция recursive_reverse')
print(
    timeit(
        "recursive_reverse(num_100)",
        setup='from __main__ import recursive_reverse, num_100',
        number=10000))
print(
    timeit(
        "recursive_reverse(num_1000)",
        setup='from __main__ import recursive_reverse, num_1000',
        number=10000))
print(
    timeit(
        "recursive_reverse(num_10000)",
        setup='from __main__ import recursive_reverse, num_10000',
        number=10000))


def memoize(f):
    cache = {}

    def decorate(*args):

        if args in cache:
            return cache[args]
        else:
            cache[args] = f(*args)
            return cache[args]

    return decorate


@memoize
def recursive_reverse_mem(number):
    if number == 0:
        return ''
    return f'{str(number % 10)}{recursive_reverse_mem(number // 10)}'


print('Оптимизированная функция recursive_reverse_mem')
print(
    timeit(
        'recursive_reverse_mem(num_100)',
        setup='from __main__ import recursive_reverse_mem, num_100',
        number=10000))
print(
    timeit(
        'recursive_reverse_mem(num_1000)',
        setup='from __main__ import recursive_reverse_mem, num_1000',
        number=10000))
print(
    timeit(
        'recursive_reverse_mem(num_10000)',
        setup='from __main__ import recursive_reverse_mem, num_10000',
        number=10000))


# Не оптимизированная функция recursive_reverse
# 0.0668427
# 0.0790341
# 0.13858089999999998
# Оптимизированная функция recursive_reverse_mem
# 0.003772000000000053
# 0.0036054999999999837
# 0.003911999999999971
#   как понял, мемоизация не уместна, кэш не будет использован  каждый вызов будет рекурсии будет разный
#



"""
Задание 3.
Приведен код, формирующий из введенного числа
обратное по порядку входящих в него
цифр и вывести на экран.
Сделайте профилировку каждого алгоритма через cProfile и через timeit
Обязательно предложите еще свой вариант решения и также запрофилируйте!
Сделайте вывод, какая из четырех реализаций эффективнее и почему!!!
Без аналитики задание считается не принятым
"""
from timeit import timeit
from cProfile import run

def revers_1(enter_num, revers_num=0):
    if enter_num == 0:
        return revers_num
    else:
        num = enter_num % 10
        revers_num = (revers_num + num / 10) * 10
        enter_num //= 10
        return revers_1(enter_num, revers_num)


def revers_2(enter_num, revers_num=0):
    while enter_num != 0:
        num = enter_num % 10
        revers_num = (revers_num + num / 10) * 10
        enter_num //= 10
    return revers_num


def revers_3(enter_num):
    enter_num = str(enter_num)
    revers_num = enter_num[::-1]
    return revers_num


def revers_4(enter_num):
    reverse_str = "".join(reversed(str(enter_num)))
    return reverse_str


num_s = 456789
print(f"{'~'*30}Timeit{'~'*30}"
      f"\nRevers 1 func time: {timeit('revers_1(num_s)', globals=globals())}"
      f"\nRevers 2 func time: {timeit('revers_2(num_s)', globals=globals())}"
      f"\nRevers 3 func time: {timeit('revers_3(num_s)', globals=globals())}"
      f"\nRevers 4 func time: {timeit('revers_4(num_s)', globals=globals())}"
      f"\n\n{'~'*30}cProfile{'~'*30}"
      f"\nRevers 1 func time: {run('revers_1(num_s)')}"
      f"\nRevers 2 func time: {run('revers_2(num_s)')}"
      f"\nRevers 3 func time: {run('revers_3(num_s)')}"
      f"\nRevers 4 func time: {run('revers_4(num_s)')}")


# из всех вариантов быстрее всего 3 вариант , четрвертый тоже, но он чуть дольше
# 4 строка дольше по причине перевода строки и возврата с распаковкой
#




"""
Задание 4.
Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.
Сделайте профилировку каждого алгоритма через timeit
Попытайтесь написать третью версию, которая будет самой быстрой и по возможности самой лаконичной.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.
Без аналитики задание считается не принятым!
"""
from timeit import timeit


array = [1, 3, 1, 3, 4, 5, 1]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'
def func_3():
    max_3 = max(array, key=array.count)
    return f'Чаще всего встречается число {max_3}, ' \
           f'оно появилось в массиве {array.count(max_3)} раз(а)'

print(func_1())
print(func_2())
print(func_3())

print(f"Func 1 time: {timeit('func_1()', globals=globals())}"
      f"\nFunc 2 time: {timeit('func_2()', globals=globals())}"
      f"\nFunc 3 time: {timeit('func_3()', globals=globals())}")

# func_3  выгоден по времени, но похож на func_1, т.к функция count() заменяет цикл который
#   использован для перебора
#
