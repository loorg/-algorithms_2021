"""
Задание 1.
Выполните профилирование памяти в скриптах.
Проанализируйте результат и определите программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.
Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов
Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)
ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

# первый вариант


from pympler import asizeof
import numpy as np


class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix

    def __add__(self, other):
        if len(self.matrix[0]) == len(other.matrix[0]):
            return Matrix([[self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0]))]
                           for i in range(len(self.matrix))])
        else:
            return f"\033[31m {'Math error. Need matrices of the same size'}"

    def __str__(self):
        return str('\n'.join(['\t'.join([str(j) for j in i]) for i in self.matrix]))


class Matrix2:
    __slots__ = ['s_matrix']

    def __init__(self, s_matrix):
        self.s_matrix = s_matrix

    def __add__(self, other):
        if len(self.s_matrix) == len(other.s_matrix):
            return ([[self.s_matrix[i][j] + other.s_matrix[i][j] for j in range(len(self.s_matrix[0]))]
                    for i in range(len(self.s_matrix))])
        else:
            return f"\033[31m {'Math error. Need matrices of the same size'}"

    def __str__(self):
        return str('\n'.join(['\t'.join([str(j) for j in i]) for i in self.s_matrix]))


matrix_1 = Matrix([[2, 24, 12], [25, 74, 28], [42, 32, 19]])
matrix_2 = Matrix([[17, 53, 1], [23, 64, 73], [91, 53, 47]])

matrix_3 = matrix_1 + matrix_2
print(f"{'*'*30} First Matrix {'*'*30}\n{matrix_1}")
print(f"{'*'*30} Second Matrix {'*'*30}\n{matrix_2}")
print(f"{'*'*30} Sum of matrix {'*'*30}\n{matrix_3}\n")

matrix_4 = Matrix2([[24, 7, 13], [23, 51, 11], [87, 62, 31]])
matrix_5 = Matrix2([[19, 17, 23], [44, 98, 21], [52, 41, 85]])
matrix_6 = matrix_4 + matrix_5
print(matrix_6)

matrix_7 = np.matrix([[36, 27, 58], [4, 12, 7], [15, 78, 31]])
matrix_8 = np.matrix([[34, 51, 86], [1, 31, 63], [18, 9, 67]])
matrix_9 = matrix_7 + matrix_8
print(matrix_6)

print(f'Dict: {asizeof.asizeof(matrix_1.__dict__)}\nSlots: {asizeof.asizeof(matrix_4.__slots__)}'
      f'\nNumpy.matrix: {asizeof.asizeof(matrix_7)}')


"""
Dict: 400
Slots: 72
Numpy.matrix: 176
Похоже, я закрыл и второе задание.
Основное задание было через класс релизовать перегрузку метода __add__ для сложения матриц. 
Вариант 1. __dict__
Матрица заняла 400 
Вариант 2. __slots__ 
Матрица заняла 72
Вариант 3. Использование matrix из бибилотеки numpy
Матрица заняла 176
"""



вариант 2

from memory_profiler import profile


@profile
def simple_alg(i):
    """Перебор делителей"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


@profile
def eratosfen_alg(i):
    """Решето Эратосфена"""
    n = 2
    l = 10000
    sieve = [x for x in range(l)]
    sieve[1] = 0
    while n < l:
        if sieve[n] != 0:
            m = n*2
            while m < l:
                sieve[m] = 0
                m += n
        n += 1

    return [p for p in sieve if p != 0][i-1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple_alg(i))
print(eratosfen_alg(i))


"""
    23     15.9 MiB     15.9 MiB           1   @profile
    24                                         def simple_alg(i):
    25                                             Перебор делителей
    26     15.9 MiB      0.0 MiB           1       count = 1
    27     15.9 MiB      0.0 MiB           1       n = 2
    28     15.9 MiB      0.0 MiB         138       while count <= i:
    29     15.9 MiB      0.0 MiB         138           t = 1
    30     15.9 MiB      0.0 MiB         138           is_simple = True
    31     15.9 MiB      0.0 MiB        2449           while t <= n:
    32     15.9 MiB      0.0 MiB        2415               if n % t == 0 and t != 1 and t != n:
    33     15.9 MiB      0.0 MiB         104                   is_simple = False
    34     15.9 MiB      0.0 MiB         104                   break
    35     15.9 MiB      0.0 MiB        2311               t += 1
    36     15.9 MiB      0.0 MiB         138           if is_simple:
    37     15.9 MiB      0.0 MiB          34               if count == i:
    38     15.9 MiB      0.0 MiB           1                   break
    39     15.9 MiB      0.0 MiB          33               count += 1
    40     15.9 MiB      0.0 MiB         137           n += 1
    41     15.9 MiB      0.0 MiB           1       return n


согласно наглядному рекурсия занимет больше места по причине хранениих стек вызовов



